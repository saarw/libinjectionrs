# Phase 1.3: Invariant Discovery - libinjection_xss

## Mathematical Relationships

### Context Coverage Invariant
```
∀ input s: libinjection_xss(s) = 1 ↔ 
    ∃ context ∈ {DATA_STATE, VALUE_NO_QUOTE, VALUE_SINGLE_QUOTE, VALUE_DOUBLE_QUOTE, VALUE_BACK_QUOTE}:
        libinjection_is_xss(s, len(s), context) = 1
```

**Interpretation**: Input is classified as XSS if and only if at least one HTML parsing context detects a dangerous pattern.

### Token Classification Completeness
```
∀ token T generated by HTML5 parser:
    T.type ∈ {DATA_TEXT, TAG_NAME_OPEN, TAG_NAME_CLOSE, TAG_NAME_SELFCLOSE, 
              TAG_DATA, TAG_CLOSE, ATTR_NAME, ATTR_VALUE, TAG_COMMENT, DOCTYPE}
```

**Interpretation**: Every token produced by the HTML5 parser has exactly one classification.

### Attribute State Consistency
```
∀ parsing sequence: attr_state(n+1) = 
    if token(n+1).type = ATTR_NAME then is_black_attr(token(n+1))
    else if token(n+1).type ≠ ATTR_VALUE then TYPE_NONE
    else attr_state(n)
```

**Interpretation**: Attribute context is set by ATTR_NAME tokens, preserved for ATTR_VALUE, and reset otherwise.

### String Comparison Equivalence
```
∀ strings a, b, length n:
    cstrcasecmp_with_null(a, b, n) = 0 ↔
        uppercase(skip_nulls(b[0..n-1])) = a ∧ a is null-terminated
```

**Interpretation**: Case-insensitive comparison with null-byte skipping in input.

## Preconditions and Postconditions

### libinjection_xss Preconditions
```
PRE: s = NULL ∨ (s points to valid memory of size ≥ slen)
PRE: slen ≥ 0
PRE: No integer overflow in slen
```

### libinjection_xss Postconditions  
```
POST: result ∈ {0, 1}
POST: No modification of input buffer s[0..slen-1]
POST: No side effects on global state
POST: Execution time bounded by O(slen * context_count)
```

### libinjection_is_xss Preconditions
```
PRE: s = NULL ∨ (s points to valid memory of size ≥ len) 
PRE: len ≥ 0
PRE: flags ∈ {DATA_STATE, VALUE_NO_QUOTE, VALUE_SINGLE_QUOTE, VALUE_DOUBLE_QUOTE, VALUE_BACK_QUOTE}
```

### libinjection_is_xss Postconditions
```
POST: result ∈ {0, 1}
POST: No modification of input buffer s[0..len-1]  
POST: HTML5 parser state is local to function call
POST: Token extraction preserves input buffer integrity
```

### Blacklist Function Postconditions
```
POST: is_black_tag(s, len) = 1 → ∃ dangerous_tag: matches(s, len, dangerous_tag)
POST: is_black_attr(s, len) ∈ {TYPE_NONE, TYPE_BLACK, TYPE_ATTR_URL, TYPE_STYLE, TYPE_ATTR_INDIRECT}
POST: is_black_url(s, len) = 1 → ∃ dangerous_protocol: startswith_ignore_case(s, len, dangerous_protocol)
```

## Loop Invariants

### Main Token Processing Loop
```c
while (libinjection_h5_next(&h5)) {
    // Loop body
}
```

**Invariants**:
1. `0 ≤ h5.pos ≤ h5.len` (position bounds)
2. `h5.s = original_input_pointer` (input pointer unchanged)
3. `h5.len = original_input_length` (input length unchanged)  
4. `h5.token_start = NULL ∨ (h5.s ≤ h5.token_start ≤ h5.s + h5.len)` (token pointer bounds)
5. `h5.token_len ≤ h5.len - (h5.token_start - h5.s)` (token length bounds)
6. `attr ∈ {TYPE_NONE, TYPE_BLACK, TYPE_ATTR_URL, TYPE_STYLE, TYPE_ATTR_INDIRECT}` (attribute state bounds)

**Termination**: `h5.pos` is monotonically non-decreasing and bounded by `h5.len`.

### HTML Entity Decoding Loop
```c
while (i < len) {
    // Process hex/decimal digits
}
```

**Invariants**:
1. `2 ≤ i ≤ len` (position bounds after initial setup)
2. `val ≥ 0` (accumulated value non-negative)
3. `consumed ≤ len` (consumption bounds)
4. `val > 0x1000FF → return '&'` (overflow protection)

**Termination**: `i` increases each iteration and is bounded by `len`.

### Blacklist Comparison Loops  
```c
while (*black != NULL) {
    // Check each blacklisted item
}
```

**Invariants**:
1. `black` points to valid stringtype_t array entry or NULL
2. Array is null-terminated (final entry has name = NULL)
3. Each array entry has valid name pointer and atype value

**Termination**: Array is finite and null-terminated.

## Memory Safety Properties

### Buffer Boundary Safety
```
∀ memory access in token processing:
    access_address ∈ [h5.s, h5.s + h5.len)
```

**Verification**: HTML5 parser enforces bounds checking through position tracking.

### Null Pointer Safety
```
∀ function calls with pointer parameters:
    NULL input → safe handling (early return or default behavior)
```

**Examples**:
- `html_decode_char_at(NULL, len, consumed)` → returns -1, sets consumed = 0
- `libinjection_h5_init(&h5, NULL, len, flags)` → handled by HTML5 parser

### Stack Overflow Prevention
```
Maximum stack depth = constant (no recursion)
Local variable space = O(1) (fixed-size structures)
```

### Integer Overflow Protection
```
∀ length calculations:
    len parameter type = size_t (platform word size)
    No signed/unsigned conversion issues
    Position arithmetic checked in HTML5 parser
```

## Implicit Contracts

### HTML5 Parser Contract
```
libinjection_h5_init() establishes parser state
libinjection_h5_next() returns false when input exhausted
Token pointers valid only until next libinjection_h5_next() call
Parser state is opaque and should not be modified externally
```

### Case-Insensitive Matching Contract
```
All HTML tag and attribute name comparisons are case-insensitive
All URL protocol comparisons are case-insensitive  
Blacklist arrays contain uppercase reference strings
Input is converted to uppercase during comparison
```

### Encoding Handling Contract
```
HTML entity decoding handles: &#decimal;, &#xhex;, &#XHEX;
Incomplete entities return partial values rather than errors
Invalid hex digits terminate parsing at first invalid character
Null bytes in input are ignored during entity decoding
```

### Multi-Context Detection Contract
```
Detection in any parsing context constitutes XSS
Contexts simulate different HTML environments (quoted/unquoted attributes, etc.)
Early termination on first positive detection (short-circuit evaluation)
Each context processes entire input independently
```

## Correctness Properties

### Soundness Property
```
libinjection_xss(s) = 1 → s contains potential XSS vector
```
**Rationale**: Function only returns 1 when known dangerous patterns are detected.

### Completeness Limitations
```
libinjection_xss(s) = 0 ↛ s is guaranteed safe
```
**Rationale**: Heuristic approach may miss novel attack vectors or context-specific vulnerabilities.

### Consistency Property
```
∀ inputs s₁, s₂: s₁ = s₂ → libinjection_xss(s₁) = libinjection_xss(s₂)
```
**Rationale**: Deterministic algorithm with no hidden state.

### Monotonicity Property  
```
∀ prefix p, suffix s: 
    libinjection_xss(p) = 1 → libinjection_xss(p + s) may be 0 or 1
    libinjection_xss(p) = 0 ↛ libinjection_xss(p + s) = 0
```
**Rationale**: Additional content can introduce new dangerous patterns, but context may also neutralize existing ones.